package flyweight;

import flyweight.enums.Color;
import flyweight.enums.Model;

import java.util.ArrayList;
import java.util.List;
/*
    Легковес(Flyweight) – это структурный паттерн проектирования, который позволяет вместить
    бóльшее количество объектов в отведённую оперативную память.
    Легковес экономит память, разделяя общее состояние объектов между собой,
    вместо хранения одинаковых данных в каждом объекте.

    Например, рассмотрим такую задачу:
     Нам нужно создать очень большое количество Айфонов, и положить их в хранилище, откуда потом их будут
     развозить по разным странам. Их количество действительно большое, и если мы будем реализовывать каждый
     телефон отдельным обьектом со всем его содержимым, оперативная память может не выдержать.

    В данном примере я показал это на 2х классах: Iphone и IphoneWithoutFlyweight(говорящие названия:))
    На моем устройстве, создание 110 000 000 обьектов класса IphoneWithoutFlyweight приводит к ошибке,
    и выходу за пределы отведенной памяти, а создание 110 000 000 обьектов класса Iphone проходит успешно.
    Почему же так происходит?
    Все дело в том, что класс, использующий паттерн Легковес, хранит большую часть своего состяния
    в отдельном классе. Обьясню, у каждого телефона есть свой серийный номер, модель, цвет и другие
    характеристики. При этом индивидуальной и уникальной характеристикой для каждого телефона является только
    серийный номер. Модель у всех телефонов может быть одинаковой, а цветов - всего 4 вариации.
    Таким образом, даже если мы будем использовать все вариации, их всего будет 6*4*3=144 (6 моделей,
    4 возможных цвета и 3 возможных размера памяти). Таким образом, паттерн предлагает хранить используемые
    типы телефонов(наши легковесы), отдельно от классов, хранящих индивидуальные неповторяющиеся
    характеристики(так называемый контекст), и добавить в них ссылку на один из 144 наших легковесов.

    Эффективность паттерна Легковес во многом зависит от того, как и где он используется.
    Применяйте этот паттерн, когда выполнены все перечисленные условия:
        - в приложении используется большое число объектов;
        - из-за этого высоки расходы оперативной памяти;
        - большую часть состояния объектов можно вынести за пределы их классов;
        - большие группы объектов можно заменить относительно небольшим количеством разделяемых объектов,
            поскольку внешнее состояние вынесено.

    Преимущества Flyweight:
        Экономит оперативную память.
    Недостатки:
        Расходует процессорное время на поиск/вычисление контекста.
        Усложняет код программы из-за введения множества дополнительных классов.


 */
public class FlyweightMain {
    public static void main(String[] args) {

        //в данном примере создается 110 млн обьектов телефона, и все они будут ссылаться на всего 1 легковес!
        //(и за счет этого занимать гораздо меньше оперативной памяти, чем )
        List<Iphone> phones = new ArrayList<>();

        for (int i = 0; i < 110_000_000; i++) {
            phones.add(new Iphone(i,
                    IphoneFactory.getIphoneType(Color.SPACE_GREY, (short) 64, Model.IPHONE_14)));
        }

        System.out.println(phones.get(228228).getType().equals(phones.get(666666).getType()));

        /* Код для создания 110 млн таких же обьектов, но без использования паттерна Flyweight
        (лично у меня, данный блок не проходит, выбрасывается исключение на переполнение памяти)
        List<IphoneWithoutFlyweight> oldPhones= new ArrayList<>();
        for (int i = 0; i < 110_000_000; i++) {
            oldPhones.add(new IphoneWithoutFlyweight(i,Color.SPACE_GREY,(short) 64, Model.IPHONE_14));
        }
        System.out.println(oldPhones.get(228228).equals(oldPhones.get(666666)));
        */


    }
}
