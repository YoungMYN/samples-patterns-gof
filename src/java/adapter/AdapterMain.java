package adapter;

import adapter.concreteEmployees.*;

import java.util.ArrayList;
import java.util.List;
/*
Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами
 работать вместе.
 */
public class AdapterMain {
    /*
    Представим конкретный пример. У нас есть предприятие Х, и все его работники реализуют интерфейс Employee.
    Каждый из них обладает собственно реализацией метода doWork, а клиентский код, или, скажем код начальника
    предприятия, имеет метод, который заставляет работать сразу все предприятие. Он следит, чтоб никто не
    отлынивал и систематически вызывает метод makeEveryoneWork. Метод работает со списком обьектов Employee,
    вызывая для каждого из них метод doWork.
    Теперь представим такую проблему. Предположим, нам на предприятии Х понадобился бухгалтер. Его работа
    будет заключаться в написании сложного математического отчета. Однако у нас сущесвует класс, который
    отлично умеет делать это действие. Это класс mathProfessor. Но профессор не работает на этом предприятии,
    и не реализует интерфейс Employee.
    Решение проблемы "в лоб": создать новый класс бухгалтера, реализовать в нем интерфейс doWork, и внутрь
    поместить копипаст метода профессора. Однако, представьте, если этот код занимает не одну, а десятки
    строк, создает множество обьектов различных классов, соединяется с базой данных и тд. Весь этот код мы
    собираемся продублировать? Конечно нет, так мы засорим нашу программу ненужным классом с уже реализованным
    ранее функционалом.
    А менять клиентский код мы не собираемся, это еще хуже. Представьте какая неразбериха будет происходить,
    если метод makeEveryoneWork будет принимать на вход список Employee, и отдельным параметром принимать
    нашего профессора. Смысл метода станет не ясен, что вообще профессор забыл на нашем предприятии???
    Метод выполняет одну единственную задачу: заставляет всех работников работать, и это легко читается.
    Если мы станем засорять его различными "левыми" классами, он быстро станет похож на свалку(представьте,
    что после профессора нам понадобится строитель, водитель и фрилансер) Что мы, так и будем менять
    клиентский код до посинения, лишь потому что классы не реализуют необходимый интерфейс?
    Вовсе нет! Есть решение.
    Мы собираемся использовать профессора как бухгалтера. Мы напишем адаптер к профессору, и программа начнет
    видеть его как работника! Условно, мы собираемся переодеть его в рабочую форму, и отправить на работу,
    и он прекрасно сможет выполнять метод doWork, поскольку внутри будет вызывать свой собственный метод, и
    писать математический отчет. Фактически, под оберткой работника будет сидеть старый-добрый профессор, но
    с отчасти ограниченным функционалом(он сможет вызывать только методы из интерфейса Employee).
    Вместо копипаста метода, мы будем вызывать его у хранимой внутри класса адаптера переменной(класса
     MathProfessor) для лучшего понимания, загляни прямо сейчас в код нашего адаптера.
     */
    public static void main(String[] args) {
        List<Employee> employees = new ArrayList<>();
        employees.add(new Courier());
        employees.add(new Developer());
        employees.add(new Security());

        Employee accountant = new MathProfessorAdapter(new MathProfessor());
        employees.add(accountant);

        makeEveryoneWork(employees);
    }
    public static void makeEveryoneWork(List<Employee> employees){
        employees.forEach(Employee::doWork);
    }

}
