package decorator;

import decorator.concreteDecorators.AggressivePersonDecorator;
import decorator.concreteDecorators.KittenLoverPersonDecorator;
import decorator.concreteDecorators.NicePersonDecorator;
import decorator.concretePersons.Man;
import decorator.concretePersons.Woman;

/*
    Декоратор (англ. Decorator) — структурный шаблон проектирования, предназначенный для динамического
    подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу
    практике создания подклассов с целью расширения функциональности.
Задача:
    Объект, который предполагается использовать, выполняет основные функции. Однако может потребоваться добавить к нему некоторую дополнительную функциональность, которая будет выполняться до, после или даже вместо основной функциональности объекта.
Способ решения
    Декоратор предусматривает расширение функциональности объекта без определения подклассов.

    Представим что город Х населен разными людьми. Пусть любой человек может:
        быть мужчиной или женщиной
        быть милым, агрессивным или нейтральным(в разных людях могут быть разные сочетания этих характеристик)
        любить котят или относится к ним нейтрально(в нашем виртуальном городе нет ненавистников котят!)

    Как же нам реализовать это в коде?
    Можно создать около 20 (по моим подсчетам) подклассов, в которых мы будем реализовывать различный характер
    жителей города,названия классов будут выглядеть примерно так: AggressiveManWhoLovesKitten,
    NiceButALittleBitAggressiveWomanWhoLovesKitten... и так далее. Представьте, что произойдет, если в город
    завезут щенков! Количство подклассов увеличится вдвое!(Поскольку теперь нужно будет создать
    по подклассу у каждого из существующих классов(с припиской...WhoLovesPuppies))

    Поэтому, мы будем использовать паттерн Декоратор!

    Класс-декоратор должен быть того же типа, что и декорируемый класс, — реализовывать тот
            же интерфейс или наследовать тот же базовый класс.
    Декоратор реализует поведение исходного класса; при этом не изменяет его, а добавляет своё
        до или после вызова базового поведения
    Это достигается за счёт того, что декоратор содержит в себе объект базового класса
        и вызывает его методы там, где требуется дополнить поведение.

    Т.е. мы создадим абстрактный класс PersonDecorator,
    который будет хранить обьект класса Person(который получает через конструктор), и при
    этом сам класс PersonDecorator будет реализовывать интерфейс Person(См. картинку structure, там нагляднее)

    И после этого создадим необходимое количество наследников(Конкретных декораторов)
    какой то будет декорировать поданый через конструктор Person под любителя котят(Дополняя
    его методы любовью к котятам), какой то будет декорировать Person под любителя щеночков, а поскольку
    сами декораторы реализуют интерфейс Person, мы можем подавать их друг другу через конструктор!
    Т.е. декорировать любителя котят под еще и любителя щеночков, а после задекорировать под
    злобного агрессивного отшельника еще пачкой декораторов(Получится лесник из песни Короля и Шута)
 */
public class DecoratorMain {
    /*
    Паттерн может показаться чем то похожим на паттерн Builder, однако у них есть координальное отличие:
    Builder - созидательный шаблон, он помогает конструировать обьект до его создания
    Decorator - структурный шаблон, позволяющий наделять уже сконструированный обьект
     дополнительным функционалом
    Суть в том, что если мы попытаемся заменить один паттерн другим, то наткнемся на то, что один создан
    во избежание создания множества подклассов, а другой - для того что бы избежать обьявления множества
     конструкторов(конструктор ключевое слово, поскольку обьект еще не создан!)

     (сейчас будет пример как делать НЕ НАДО)
     Если бы мы постарались применить декоратор к СОЗДАНИЮ, например бургера, то это выглядело так:
        Burger burger = new Burger();
        Burger burgerWithSouse = new SouseBurgerDecorator(burger);
        Burger burgerWithMeatAndSouse = new MeatBurgerDecorator(burgerWithSouse);
     Но что это такое?! Использование шаблона декоратора для создания объектов плохо,
      потому что он оставляет объект в несогласованном (или, по крайней мере, неправильном)
      состоянии до тех пор, пока не будут установлены все необходимые декораторы. И правда, что за обьект -
      burger? Мы можем им хоть где то воспользоваться? Нет, как и обьектом burgerWithSouse, потому что в нем
      нет ни мяса ни овощей. Вск эти промежуточные состояния не нужно выделять в отдельные обьекты

      ПРАВИЛЬНО будет написать ВОТ ТАК:
        Burger burger = burgerBuilder.addSouse().addMeat().addVegetables().build();
      Никаких костыльных обьектов не создается, мы билдим бургер только после того, как добавлили в него
        все необходимое.(Фух, надеюсь, понятно обьяснил)

     */
    public static void main(String[] args) {
        Person simpleMan = new Man();
        simpleMan.sayHello();
        simpleMan.introduceYourself();

        System.out.println();
        System.out.println("-------------------------------");

        Person angryTopGMan = new AggressivePersonDecorator(new Man());
        angryTopGMan.sayHello();
        angryTopGMan.introduceYourself();

        System.out.println();
        System.out.println("-------------------------------");

        Person niceWoman = new NicePersonDecorator(new Woman());
        niceWoman.sayHello();
        niceWoman.introduceYourself();

        System.out.println();
        System.out.println("-------------------------------");

        Person niceWomanWhoLovesKittens = new KittenLoverPersonDecorator(new NicePersonDecorator(new Woman()));
        niceWomanWhoLovesKittens.sayHello();
        niceWomanWhoLovesKittens.introduceYourself();
    }
}
