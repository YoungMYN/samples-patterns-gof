package structural.facade;
/*
    Фасад – это структурный паттерн проектирования, который предоставляет простой интерфейс
    к сложной системе классов, библиотеке или фреймворку.

    Проблема:
    Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка.
    Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и тд.
    В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов.
    Такой код довольно сложно понимать и поддерживать.

    Решение
    Фасад – это простой интерфейс для работы со сложной подсистемой, содержащей множество классов.
    Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь,
    используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту,
    и скрывает все остальные.
    Фасад полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей,
    но вам нужна только часть её возможностей.

    Например, клиентский код может использовать профессиональный сервис доставки еды, и самостоятельно
    давать распоряжения сборщику, упаковщику и доставщику, возможно в каких то случаях нам нужен будет такой
    функционал, НО обычно, все, что нужно клиенту - это без лишних заморочек заказать еду, и ему не важно,
    какую службу доставки мы используем, он просто хочет ввести адрес и выбрать продукты.

    Тогда мы можем просто использовать функционал класса-фасада OnlineShopFacade.
    Вместо непосредственной работы с дюжиной-другой классов, фасад предоставляет коду приложения
    единственный метод для заказа продуктов на дом, который сам заботится о том,
    чтобы правильно сконфигурировать нужные объекты фреймворка и получить требуемый результат.

    Помимо гораздо более простого интерфейса, есть еще одно преимущество использования этого шаблона
    проектирования. Он отделяет реализацию клиента от сложной подсистемы.
    Благодаря этому мы можем вносить изменения в существующую подсистему и не затрагивать клиента.

    Так же фасад может хранить внутри себя ссылку на другой фасад, и использовать его методы, которые
    в свою очередь могут использользовать методы вложенного фасада, что бы разделить ответственность и
    увеличить читаемость кода.
    Задумайтесь о введении дополнительного фасада(ов), если ответственность фасада начинает размываться(SRP)

    Недостатки
    Фасад рискует стать божественным объектом, привязанным ко всем классам программы.
 */

import static structural.facade.enums.Products.*;

public class FacadeMain {
    public static void main(String[] args){
        /*
        Пример кода, который нужно было бы каждый раз писать для заказа еды,
        если бы мы не использовали фасад:

        OrderPickingService orderPickService = new OrderPickingService();
        PackingService packingService = new PackingService();
        DeliveryService deliveryService = new DeliveryService();

        List<Products> products = orderPickService.pickOrder(Products.MANGO,Products.PINEAPPLE);
        ProductPackage pack= packingService.pack(products);
        deliveryService.sendPackage("MyAddress", pack);
         */
        //Как выглядит код с использованием паттерна Facade (Да, паттерн позволяет избежать повторения
        // создания сложного и плохочитаемого блока кода, каждый раз, когда нам нужно заказать продукты)
        OnlineShopFacade onlineShopFacade = new OnlineShopFacade();

        ProductPackage pack = onlineShopFacade.buyAndDeliver("MyAddress", MANGO, PINEAPPLE);
        pack.open();
    }
}
