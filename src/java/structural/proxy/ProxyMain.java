package structural.proxy;
/*
    Заместитель(Proxy) – это структурный паттерн проектирования, который позволяет подставлять вместо реальных
    объектов специальные объекты-заменители.
    Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до
    или после передачи вызова оригиналу.

    Для чего вообще контролировать доступ к объектам?Рассмотрим такой пример: у вас есть внешний
    и очень ресурсоёмкий объект, который нужен не всё время, а изредка.

    Мы могли бы создавать этот объект не в самом начале программы, а только тогда, когда он кому-то
    реально понадобится. Каждый клиент объекта получил бы некий код отложенной инициализации.
    Но, вероятно, это привело бы к множественному дублированию кода.

    В идеале, этот код хотелось бы поместить прямо в служебный класс, но это не всегда возможно.
    Например, код класса может находиться в закрытой сторонней библиотеке.

    Решение
    Паттерн Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс,
    что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы
    создавал экземпляр служебного объекта и переадресовывал бы ему всю реальную работу.
    Таким образом, экземпляр ресурсоемкого обьекта будет создан, лишь тогда, когда он реально требуется и
    не будет занимать лишнее место в оперативной памяти.

    Так же Заместитель может делать дополнительную работу: например, кэшировать результаты работы обьекта
    и без надобности не запускать сложный ресурсоемкий процесс заново.

    Рассмотрим пример, код который я реализовал. У нас есть класс соединения с базой данных(RealDBC),
    который реализует интерфейс DatabaseConnection.
    Если бы мы создавали экземпляр реального соединения с базой данных в начале программы,
    то он бы просто висел в оперативной памяти, до тех пор, пока нам не понадобится(а это может быть еще ой
    как не скоро).
    Но, поскольку вместо создания экземпляра реального соединения, мы используем Заместителя, он вообще
    практически не занимает места в оперативной памяти(по крайней мере сразу после создания).
    Но, когда нам реально понадобится какой то из методов нашего соединения мы вызовем его у Заместителя,
    а он в свою очередь, передаст ее настоящему экземпляру соединения и, перед этим или до,
    сделает какую-нибудь полезную работу(их может быть большое множество, например: ленивая инициализация,
    проверка доступа перед выполнением(вдруг запрашивающий клиент не имеет права выполнять эту операцию),
    кэширование результа вызовов для последующего ускорения работы и тд).

    Вот несколько разновидностей прокси:
    (Субьект - общий интерфейс, Реальный субьект и Заместитель - реализации этого интерфейса)

    -Протоколирующий прокси: сохраняет в лог все вызовы «Субъекта» с их параметрами.

    -Удалённый заместитель (англ. remote proxies): обеспечивает связь с «Субъектом», который находится
     в другом адресном пространстве или на удалённой машине. Также может отвечать за кодирование запроса
     и его аргументов и отправку закодированного запроса реальному «Субъекту»,

    -Виртуальный заместитель (англ. virtual proxies): обеспечивает создание реального «Субъекта» только
     тогда, когда он действительно понадобится. Также может кэшировать часть информации о реальном
     «Субъекте», чтобы отложить его создание.

    -Защищающий заместитель (англ. protection proxies): может проверять, имеет ли вызывающий объект
     необходимые для выполнения запроса права.

    -Кэширующий прокси: обеспечивает временное хранение результатов расчёта до отдачи их множественным
     клиентам, которые могут разделить эти результаты.

    -Экранирующий прокси: защищает «Субъект» от опасных клиентов (или наоборот).

    -Синхронизирующий прокси: производит синхронизированный контроль доступа к «Субъекту» в асинхронной
     многопоточной среде.

    -«Умная» ссылка (англ. smart reference structural.proxy): производит дополнительные действия, когда на «Субъект»
     создается ссылка, например, рассчитывает количество активных ссылок на «Субъект».
 */
public class ProxyMain {
    public static void main(String[] args) {
        /*
        В данном примере прокси выполняет 2 полезные функции: Ленивую инициализацию и кэширование
        Видно, что мы создаем обьект класса DatabaseConnection, но при этом никаких ресурсоемких обьектов
        еще не создано, это всего лишь заместитель.
         */
        DatabaseConnection databaseConn = new ProxyDatabaseConnection();
        /*
        ...
        some client code
        ...
        ...
         */
        //Как только нам понадобился обьект реального соединения с базой, для, например, коммита, мы создадим
        // его внутри прокси с помощью механизма ленивой инициализации
        databaseConn.commit();
        for(int i=0;i<100;i++) {
            /*
            Видно, что заместитель не будет 100 раз обращатся к реальному обьекту, он будет брать
            кэшированные ранее результаты его работы и таким образом обратится к обьекту RealDBC всего 1 раз!
             */
            System.out.println(databaseConn.getClientInfo("Ivan"));
        }
        databaseConn.close();
    }
}
/*
    Преимущества
        +Позволяет контролировать сервисный объект незаметно для клиента.
        +Может работать, даже если сервисный объект ещё не создан.
        +Может контролировать жизненный цикл служебного объекта.
    Недостатки
        -Усложняет код программы из-за введения дополнительных классов.
        -Увеличивает время отклика от сервиса.
 */
