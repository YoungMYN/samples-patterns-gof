package state;

/*
    Состояние (State) - поведенческий шаблон проектирования, который позволяет объекту
    изменять свое поведение в зависимости от внутреннего состояния.

    Паттерн состоит из 3 блоков:

    Widget — класс, объекты которого должны менять своё поведение в зависимости от состояния.

    IState — интерфейс, который должен реализовать каждое из конкретных состояний.
    Через этот интерфейс объект Widget взаимодействует с состоянием, делегируя ему вызовы методов.
    Интерфейс должен содержать средства для обратной связи с объектом, поведение которого нужно изменить.

    StateA … StateZ — классы конкретных состояний. Должны содержать информацию о том, при каких условиях
    и в какие состояния может переходить объект из текущего состояния.
    Например, из StateA объект может переходить в состояние StateB и StateC, а из StateB — обратно в StateA
    и так далее. Объект одного из них должен содержать Widget при создании.

    Паттерн Состояние предлагает создать отдельные классы для каждого состояния, в котором может пребывать
    объект, а затем вынести туда поведения, соответствующие этим состояниям.
    Вместо того, чтобы хранить код всех состояний, первоначальный объект, называемый контекстом,
    будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.

    Благодаря тому, что объекты состояний будут иметь общий интерфейс, контекст сможет делегировать
    работу состоянию, не привязываясь к его классу. Поведение контекста можно будет изменить в любой момент,
    подключив к нему другой объект-состояние.

    Очень важным нюансом, отличающим этот паттерн от паттерна Strategy, является то, что и контекст, и
    сами конкретные состояния могут знать друг о друге и инициировать переходы от одного состояния к другому.

    В данном конкретном примере я реализовал класс человека, который может бежать кросс.
    У этого человека есть несколько состояний, бодрое, уставшее и полностью истощенное.
    Эти состояния со временем сменяют друг друга, ведь человек устает со временем, и, соответственно
    меняется и реализация метода runCross.

    В общем случае код методов в классах реализующих IState выглядит примерно так:
        public void action(Context context) {
            //do something..
            context.setState(new AnotherState());
        }
    Т.е. в классе Context мы будем передавать в метод нашего State обьект this, а это конкретное состояние
    будет само решать, что делать дальше, руководствуясь своей логикой, и, при надобности, самостоятельно
    менять текущее State класса Context на другое.

    Применимость:

    Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния,
    причём типов состояний много, и их код часто меняется.
        Паттерн предлагает выделить в собственные классы все поля и методы, связанные с определёнными
        состояниями. Первоначальный объект будет постоянно ссылаться на один из объектов-состояний,
        делегируя ему часть своей работы.
        Для изменения состояния в контекст достаточно будет подставить другой объект-состояние.

    Когда код класса содержит множество больших, похожих друг на друга, условных операторов,
    которые выбирают поведения в зависимости от текущих значений полей класса.
        Паттерн предлагает переместить каждую ветку такого условного оператора в собственный класс.
        Тут же можно поселить и все поля, связанные с данным состоянием.

    Когда вы сознательно используете табличную машину состояний, построенную на условных операторах,
    но вынуждены мириться с дублированием кода для похожих состояний и переходов.
        Паттерн Состояние позволяет реализовать иерархическую машину состояний, базирующуюся на наследовании.
        Вы можете отнаследовать похожие состояния от одного родительского класса и вынести туда весь
        дублирующий код.
 */
public class StateMain {
    public static void main(String[] args) {
        Human john = new Human("John Smith");

        for (int i = 0; i < 3; i++) {
            john.runCross();
        }
    }
}
/*
Преимущества
    +Избавляет от множества больших условных операторов машины состояний.
    +Концентрирует в одном месте код, связанный с определённым состоянием.
    +Упрощает код контекста.
Недостатки
    -Может неоправданно усложнить код, если состояний мало и они редко меняются.
 */