package behavioral.interpreter;
/*
    Интерпретатор(Interpreter)-поведенческий шаблон проектирования, решающий часто встречающуюся,
    но подверженную изменениям, задачу. Также известен как Little Language.

    Интерпретатор позволяет описать алгоритм со своей грамматикой и определенными правилами
    для решения конкретной задачи. Короче говоря, данный шаблон позволяет описать механизм
    вычисления конкретной задачи с заданным синтаксисом.

    Абстрактный базовый класс определяет метод interpret(), обычно(не не всегда) принимающий
    (в качестве аргумента) текущее состояние языкового потока.
    Каждый конкретный подкласс реализует метод interpret(), добавляя свой вклад в процесс решения проблемы.

    Обьясню, в данной реализации паттерна, я не передаю обьект Context в метод interpret, однако
    возможна такая структура, когда каждый Nonterminal expression совершает какие то изменения в общем обьекте
    контекста, и передает его дальше, вызывая методы interpret у вложенных обьектов Expression,
    они в свою очередь делают тоже самое и так далее,
    пока дело не доходит до вызова метода interpret у какого либо Terminal Expression.
    (Terminal - возвращает конкретное значение. Nonterminal - совершают операцию и передают дальше)
    А вызов метода interpret в Terminal Expression запустит какой либо сложный метод в обьекте Context,
    который будет выполнен с учетом всех изменений внесенных в него всеми реализациями Expression.

    Советую заглянуть в класс Context и почитать комментарий начет работы данного класса.
    (и, разумеется посмотреть файл structure.png)
    Но если коротко, то Context определяет правило, по которому парсится строка и создается Expression,
    А получить итоговый результат мы сможем вызвав метод interpret у одного Expression,
    и это запустит каскадный вызов у всех вложенных обьектов Expression, и мы получим результат.
    (в этом то в общем то и есть сахар данного паттерна)
 */
public class InterpreterMain {
    public static void main(String[] args) {
        Context context = new Context();
        Expression exp = context.evaluate("2+3+4-10");
        System.out.println(exp.interpret());
    }
}
/*
Преимущества
    +Грамматику легко изменять и расширять.
        Поскольку для представления грамматических правил в паттерне используются классы,
        то для изменения - или расширения грамматики можно применять наследование.
        Существующие выражения можно модифицировать постепенно, а новые определять
        как вариации старых (компоновка, агрегация старых).
    +Простая реализация грамматики.
        Реализации классов, описывающих узлы абстрактного синтаксического дерева, похожи.
        Такие классы легко кодировать, а зачастую их может автоматически сгенерировать компилятор
        или генератор синтаксических анализаторов.
Недостатки
    -Сложные грамматики трудно сопровождать.
        В паттерне интерпретатор определяется по меньшей мере один класс для каждого правила
        грамматики (для правил, определенных с помощью формы Бэкуса-Наура – BNF,
        может понадобиться и более одного класса).
        Поэтому сопровождение грамматики с большим числом правил иногда оказывается трудной задачей.
        Для ее решения могут быть применены другие паттерны. Но если грамматика очень сложна,
        лучше прибегнуть к другим методам, например, воспользоваться генератором компиляторов
        или синтаксических анализаторов.
    -Добавление новых способов интерпретации выражений.
        Паттерн интерпретатор позволяет легко изменить способ вычисления выражений.
        Например, реализовать красивую печать выражения вместо проверки входящих в него типов можно,
        просто определив новую функциональность операции Interpret в классах выражений.

        Ну а если вам приходится часто создавать новые способы интерпретации выражений,
        подумайте о применении паттерна посетитель.
        Это поможет избежать изменения классов, описывающих грамматику.
 */