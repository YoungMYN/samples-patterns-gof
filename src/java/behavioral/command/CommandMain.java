package behavioral.command;

import behavioral.command.concreteCommands.PrintHelloWorld;
import behavioral.command.concreteCommands.TurnOff;
import behavioral.command.concreteCommands.TurnOn;
/*
    Команда(Command) - это поведенческий паттерн проектирования, который превращает запросы в объекты,
    позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их,
    а также поддерживать отмену операций.

    Цель паттерна:
    Создание структуры, в которой класс-отправитель и класс-получатель не зависят друг от друга напрямую.
    Организация обратного вызова к классу, который включает в себя класс-отправитель.

    Проблема:
    У нас есть готовый класс КНОПКА, и мы хотим использовать его везде, где это возможно, однако тогда нам
    придется создать 100500+ наследников этого класса, переопределяющих метод onClick(), ведь какие-то
    кнопки у нас будут отвечать за закрытие программы, какие-то - за копирование, другие - за проигрывание
    видео и тд.

    Решение:
    Каждая кнопка будет нашим Invoker, и класс будет хранить в себе экземпляр обьекта Command, и по клику
    просто выполнять единственный метод execute, а сама команда уже позаботится о передаче действия нашему
    receiver. Таким, в самом классе не хранится какое то конкретное поведение при нажатии, это поведение
    будет определяться при создании обьекта класса(мы будем передавать обьект Command через
    конструктор, например. Или с помощью метода setCommand()). Таким образом команды можно будет
    взаимозаменять на лету, изменяя итоговое поведение отправителей.

    Параметры, с которыми должен быть вызван метод объекта получателя, можно загодя сохранить в полях
    объекта-команды. Благодаря этому, объекты, отправляющие запросы, могут не беспокоиться о том,
    чтобы собрать необходимые для получателя данные. Более того, они теперь вообще не знают,
    кто будет получателем запроса. Вся эта информация скрыта внутри команды.
    Таким образом, команды станут гибкой прослойкой между пользовательским интерфейсом и бизнес-логикой.
    И это лишь малая доля пользы, которую может принести паттерн Команда!

    Как всегда, советую глянуть картинку structure.png, там ключевые моменты, станет понятнее.

    В текущем примере - команды являются прослойкой между Invoker'ом - Control Panel и Receiver'ом Computer
    Панель управления регистрирует необходимые команды, производит различные полезные
    действия(логирование, например) и, при необходимости выполняет нужные команды, которые сами передают запрос
    к компьютеру.

    Шаблон Команда может быть полезен в следующих случаях:

    -Кнопки пользовательского интерфейса и пункты меню
    -Запись макросов
    -Многоуровневая отмена операций (Undo)
        Если все действия пользователя в программе реализованы в виде командных объектов,
        программа может сохранить стек последних выполненных команд.
        Когда пользователь хочет отменить команду, программа просто выталкивает последний объект команды
        и выполняет его метод undo().
    -Сети
        Можно отправить объекты команд по сети для выполнения на другой машине,
        например действие игрока в компьютерной игре.
    -Индикаторы выполнения
        Предположим, что программа имеет последовательность команд, которые она выполняет по порядку.
        Если каждый объект команды имеет метод getEstimatedDuration() (получить оценочную длительность),
        программа может легко оценить общую продолжительность процесса. Она может показать индикатор
        выполнения, который отражает, насколько близка программа к завершению всех задач.
    -Пулы потоков
        Типичный класс пула потоков общего назначения может иметь метод addTask(),
        который добавляет рабочий элемент к внутренней очереди заданий ожидающих своего выполнения.
        Он поддерживает пул потоков, которые выполняют команды из очереди.
        Элементы в очереди являются объектами команд. Как правило, эти объекты реализуют общий интерфейс,
        такой как java.lang.Runnable, что позволяет пулу потоков запустить команды на выполнение,даже если
        он сам был написан без каких-либо знаний о конкретных задачах, для которых он будет использоваться.
    -Транзакции
        Аналогично операции «отмена» система управления базами данных (СУБД) или установщик программного
        обеспечения может хранить список операций, которые были или будут выполнены.
        Если одна из них закончится неудачей, то все остальные могут быть отменены или быть отброшены
        (обычно называется откат). Например, если две связанные между собой таблицы базы данных должны
        быть обновлены, а второе обновление терпит неудачу, то система может откатить транзакцию,
        чтобы первая таблица не содержала недопустимую ссылку.
    -Мастера
        Часто мастер (мастер установки или любой другой) представляет несколько страниц конфигурации
        для одного действия, которое происходит только тогда, когда пользователь нажимает на кнопку
        «Готово» на последней странице. В этих случаях, естественный способ отделить код пользовательского
        интерфейса от кода приложения является реализация мастера с помощью объекта команд.
        Объект команда создается при первом отображении мастера. Каждая страница мастера сохраняет свои изменения в объекте команды, поэтому объект заполняется по мере перехода пользователя. Кнопка «Готово» просто запускает метод execute() на выполнение.
 */
public class CommandMain {
    public static void main(String[] args) {
        Computer computer = new Computer();

        Command turnOn = new TurnOn(computer);
        Command turnOff = new TurnOff(computer);
        Command printHW = new PrintHelloWorld(computer);

        ControlPanel controlPanel = new ControlPanel();
        controlPanel.register("on",turnOn);
        controlPanel.register("off",turnOff);
        controlPanel.register("printHW",printHW);

        controlPanel.execute("on");
        controlPanel.execute("printHW");
        controlPanel.undoLastExecutedCommand();
        controlPanel.execute("off");
    }
}
/*
Преимущества
    +Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
    +Позволяет реализовать простую отмену и повтор операций.
    +Позволяет реализовать отложенный запуск операций.
    +Позволяет собирать сложные команды из простых.
    +Реализует принцип открытости/закрытости.
Недостатки
    -Усложняет код программы из-за введения множества дополнительных классов.
 */