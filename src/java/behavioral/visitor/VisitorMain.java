package behavioral.visitor;

import behavioral.visitor.concreteElements.*;
import behavioral.visitor.concreteVisitors.*;

import java.util.ArrayList;
import java.util.List;
/*
    Посетитель(Visitor) - поведенческий паттерн проектирования, описывающий операцию, которая выполняется
    над объектами других классов. При изменении behavioral.visitor нет необходимости изменять обслуживаемые классы.

    Шаблон так же позволяет получить информацию о типе объекта, без использования понижающего приведения типов
    т.е. без if instanceOf First, else if instanceOf Second и так далее (Считается плохим тоном и может привести
    к нарушению LSP)
    при помощи механизма двойной диспетчеризации(Об этом чуть ниже).

    Паттерн Visitor позволяет сделать универсальный обход структуры. Он становится полезен, когда мы имеем
    не один объект из семейства, а структуру из множества объектов.
    Основная идея данного приема — избавиться от god-метода со пресловутым switch;
    Ведь, например, внутри треугольника могут лежать квадраты, в которых есть другие треугольники.
    А у вас Visitor знает только то, как работать с одним треугольником и с одним квадратом.
    То, как они друг в друга входят, посетитель не знает. Как только Visitor обработал одну фигуру,
    управление передается в метод accept, а там уже наш Visitor получит для обработки следующую фигуру.
    Это гораздо удобнее, чем создавать гигансткий, выше упомянутый god-switch блок
    Соответственно, чаще всего паттерн Visitor используется в связке с паттерном Composite.


    Этот паттерн применяется в ситуациях, когда нам необходимо добавить какой-то дополнительный функционал
    некоторой группе обьектов, и при этом не хотим менять ни код родительских классов, ни код дочерних.
    Обычно это происходит когда нам необходимо добавить какой то функционал при обходе структуры обьектов.
    Например, нам вдруг понадобится метод экспорта в csv каждого из классов этой структуры.
    Для каждого такого класса этот экспорт будет производится по своему, а создавать в родительском классе
    метод exportToPdf будет не совсем корректно в отношении SRP(Вдруг нам понадобится экспорт в txt и тд,
    тогда код класса родителя будет сильно загрязнен).
    Конспектируя:
        -Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.
        -Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции,
          но вы не хотите «засорять» классы такими операциями.
        -Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.

    Итак, паттерн Посетитель предлагает разместить новое поведение, которое нам требуется добавить,
    в отдельном классе(ExportToPDFVisitor), вместо того чтобы множить его сразу в нескольких классах.
    Объекты, с которыми должно было быть связано поведение, не будут выполнять его самостоятельно.
    Вместо этого вы будете передавать эти объекты в методы посетителя.

    Код поведения, скорее всего, должен отличаться для объектов разных классов, поэтому и методов
    у посетителя должно быть несколько. Названия и принцип действия этих методов будет схож, но основное
    отличие будет в типе принимаемого в параметрах объекта(void visit(ConcreteA a), void visit(ConcreteB b) и тд)

    https://radioprog.ru/post/1510 - очень понятная и короткая статья про двойную диспетчеризацию,
    если вдруг кто забыл или не знал.
    Напомню: именно из-за раннего связывания мы не можем просто передавать в меттоды Visitor обьекты
    напрямую. Потому что тогда мы не сможем пользоваться полиморфизмом в клиентском коде.
    То есть если у нас есть условный List<Animal> animals, где Animal - абстрактный класс, и будем
    пытаться вызвать behavioral.visitor.visit(animal) для каждого animal из animals, то будет испльзована(если существует)
    реализация метода visit(Animal animal), а не visit(ConcreteAnimal concreteAnimal). (А если родительской
    реализации не существует компилятор вообще выдаст ошибку).
    И именно поэтому мы пользуемся трюком двойной диспетчеризации, создаем интерфейс Element с единственным
    методом accept(Visitor behavioral.visitor), и в этом методе уже выполняем behavioral.visitor.visit(this), и вот уже при
    использовании this компилятор захватит именно реализацию метода под данный конкретный класс.

    Однако, нужно помнить, что шаблон устроен таким образом, что добавление нового класса(нового Element)
    приведет к необходимости корректировать интерфейс Visitor, добавляя в него новую вариацию метода visit,
    и, соответственно, придется редактировать абсолютно все ConcreteVisitor. Это сделает код максимально
    не гибким. Таким образом, паттерн Visitor используют при наличии устоявшейся иерархии.
    Если мы проектируем расширяемую библиотеку, использовать визитор мы никак не можем.
 */

public class VisitorMain {
    public static void main(String[] args) {
        List<Element> farm = new ArrayList<>();

        BeeHive beeHive = new BeeHive();
        beeHive.add(new Bee(1));
        beeHive.add(new Bee(2));
        beeHive.add(new Bee(3));

        farm.add(beeHive);
        farm.add(new Cat());
        farm.add(new Dog());

        Visitor visitor = new GoodVisitor();
        for(Element e : farm){
            e.accept(visitor);
        }
    }
}
/*
    Преимущества
        +Упрощает добавление операций, работающих со сложными структурами объектов.
        +Объединяет родственные операции в одном классе.
        +Посетитель может накапливать состояние при обходе структуры элементов.
    Недостатки
        -Паттерн не оправдан, если иерархия элементов часто меняется.
        -Может привести к нарушению инкапсуляции элементов.
 */